use std::sync::{Arc, Mutex};
use cpal::traits::{DeviceTrait, HostTrait, StreamTrait};
use cpal::{Stream, StreamConfig};

pub struct AudioProcessor {
    pub waveform: Arc<Mutex<Vec<f64>>>,
    pub fft_result: Arc<Mutex<Vec<f64>>>,
    pub dominant_frequency: Arc<Mutex<f64>>,
    stream: Option<Stream>,
}

impl AudioProcessor {
    pub fn new() -> Self {
        Self {
            waveform: Arc::new(Mutex::new(vec![0.0; 256])),
            fft_result: Arc::new(Mutex::new(vec![0.0; 128])),
            dominant_frequency: Arc::new(Mutex::new(0.0)),
            stream: None,
        }
    }

    pub fn start_listening(&mut self) {
        let host = cpal::default_host();
        let device = host.default_input_device().expect("No input device found");
        let config = device.default_input_config().unwrap().into();

        let waveform_clone = Arc::clone(&self.waveform);
        let fft_result_clone = Arc::clone(&self.fft_result);
        let dominant_frequency_clone = Arc::clone(&self.dominant_frequency);

        let stream = device.build_input_stream(
            &config,
            move |data: &[f32], _: &cpal::InputCallbackInfo| {
                let mut waveform_data = waveform_clone.lock().unwrap();
                waveform_data.clear();
                waveform_data.extend(data.iter().map(|&s| s as f64));

                let mut fft_data = fft_result_clone.lock().unwrap();
                *fft_data = AudioProcessor::compute_fft(&waveform_data);

                let mut dominant_freq = dominant_frequency_clone.lock().unwrap();
                *dominant_freq = AudioProcessor::find_dominant_frequency(&fft_data);
            },
            |err| eprintln!("Stream error: {:?}", err),
            None,
        ).unwrap();

        stream.play().unwrap();
        self.stream = Some(stream);
    }

    pub fn stop_listening(&mut self) {
        self.stream = None;  // Dropping the stream stops recording
    }

    fn compute_fft(samples: &[f64]) -> Vec<f64> {
        samples.iter().map(|&s| s.abs()).collect() // Placeholder for FFT logic
    }

    fn find_dominant_frequency(fft_data: &[f64]) -> f64 {
        fft_data.iter()
            .enumerate()
            .max_by(|a, b| a.1.partial_cmp(b.1).unwrap())
            .map(|(index, _)| index as f64)
            .unwrap_or(0.0)
    }
}
