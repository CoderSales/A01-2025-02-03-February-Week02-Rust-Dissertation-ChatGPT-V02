use rustfft::{FftPlanner, num_complex::Complex}; // Old
use std::f32::consts::PI; // Old
use std::sync::{Arc, Mutex}; // New
use std::time::{Instant, Duration}; // Old, Moved
use std::thread; // New

const SAMPLE_RATE: f32 = 44100.0; // Old
const MIN_PEAK_MAGNITUDE: f32 = 5.0; // Old
const MAX_PEAKS: usize = 10; // Old
const FFT_SIZE: usize = 2048; // Old

/// Perform FFT and return raw frequency spectrum + top peaks (V01)
// Edited, Warnings moved out
// Edited: Call display_amplitude() in analyze_frequencies()
pub fn analyze_frequencies(samples: &[f32]) -> Vec<(f32, f32)> {
    let mean = samples.iter().sum::<f32>() / samples.len() as f32; // old
    let centered_samples: Vec<f32> = samples.iter().map(|&s| s - mean).collect(); // old

    let raw_amplitude = centered_samples.iter().map(|&x| x.abs()).sum::<f32>() / centered_samples.len() as f32; // Old
    
    let mut silence_count = 0; // New
    let mut total_frames = 0; // New

    display_amplitude(raw_amplitude, &mut silence_count, &mut total_frames); // New

    if raw_amplitude < MIN_PEAK_MAGNITUDE {
        return vec![];
    }

    let hann_window: Vec<f32> = (0..FFT_SIZE)
        .map(|i| 0.5 * (1.0 - (2.0 * PI * i as f32 / (FFT_SIZE - 1) as f32).cos()))
        .collect();

    let windowed_samples: Vec<f32> = centered_samples
        .iter()
        .zip(hann_window.iter())
        .map(|(s, w)| s * w)
        .collect();

    let mut planner = FftPlanner::new();
    let fft = planner.plan_fft_forward(windowed_samples.len());

    let mut buffer: Vec<Complex<f32>> = windowed_samples.iter().map(|&s| Complex::new(s, 0.0)).collect();
    fft.process(&mut buffer);

    let magnitude_spectrum: Vec<f32> = buffer.iter().map(|c| c.norm()).collect();
    
    let mut peaks: Vec<(f32, f32)> = vec![];

    for (i, &magnitude) in magnitude_spectrum.iter().enumerate().take(FFT_SIZE / 2) {
        let freq = (i as f32) * (SAMPLE_RATE / FFT_SIZE as f32);
        let prev = if i > 0 { magnitude_spectrum[i - 1] } else { 0.0 };
        let next = if i < magnitude_spectrum.len() - 1 { magnitude_spectrum[i + 1] } else { 0.0 };

        if magnitude > prev && magnitude > next && magnitude > MIN_PEAK_MAGNITUDE {
            peaks.push((freq, magnitude));
        }
    }

    peaks.sort_by(|a, b| b.1.partial_cmp(&a.1).unwrap());
    peaks.truncate(MAX_PEAKS);

    peaks
}

// new, timer:
/// Timer thread that ensures final summary prints after recording
pub fn start_timer(silence_count: Arc<Mutex<usize>>, total_frames: Arc<Mutex<usize>>) {
    thread::spawn(move || {
        thread::sleep(Duration::from_secs(30)); // Simulate program run duration

        let silence = *silence_count.lock().unwrap();
        let total = *total_frames.lock().unwrap();
        let silence_percentage = (silence as f32 / total as f32) * 100.0;

        println!("\n✅ Final Analysis: {}% of the recording was silent.", silence_percentage);
    });
}
// old, edited, last_warning removed:
/// Display amplitude visualization and track silence
// Edited: Make display_amplitude() public
pub fn display_amplitude(amplitude: f32, silence_count: &mut usize, total_frames: &mut usize) {
    *total_frames += 1; // Track total frames // New

    let bars = (amplitude * 50.0) as usize;
    let bass = if bars > 30 { "█" } else { " " }; // Edited
    let mids = if bars > 15 { "█" } else { " " }; // Edited
    let treble = if bars > 5 { "█" } else { " " }; // Edited

    // Track silence percentage // New
    if bars == 0 {
        *silence_count += 1;
    }

    // Limit refresh rate to every 50 frames (~0.5s) // Edited
    if *total_frames % 50 == 0 {
        println!("\nBass |{}\nMids |{}\nTreble |{}\n", bass, mids, treble); // Edited for vertical alignment
    }
}
